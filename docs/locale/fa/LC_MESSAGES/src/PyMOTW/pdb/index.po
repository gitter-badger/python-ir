# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2016, Python-ir.org
# This file is distributed under the same license as the Python-ir package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2016.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python-ir 0.1\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2016-05-07 20:31+0430\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.3.4\n"

#: ../../src/PyMOTW/pdb/index.rst:3
msgid "pdb -- Interactive Debugger"
msgstr ""

#: ../../src/PyMOTW/pdb/index.rst:8
msgid "Python's Interactive Debugger"
msgstr ""

#: ../../src/PyMOTW/pdb/index.rst:9
msgid "1.4 and later"
msgstr ""

#: ../../src/PyMOTW/pdb/index.rst:11
msgid ""
":mod:`pdb` implements an interactive debugging environment for Python "
"programs.  It includes features to let you pause your program, look at "
"the values of variables, and watch program execution step-by-step, so you"
" can understand what your program actually does and find bugs in the "
"logic."
msgstr ""

#: ../../src/PyMOTW/pdb/index.rst:18
msgid "Starting the Debugger"
msgstr ""

#: ../../src/PyMOTW/pdb/index.rst:20
msgid ""
"The first step to using :mod:`pdb` is causing the interpreter to enter "
"the debugger when you want it to.  There are a few different ways to do "
"that, depending on your starting conditions and what you need to debug."
msgstr ""

#: ../../src/PyMOTW/pdb/index.rst:26
msgid "From the Command Line"
msgstr ""

#: ../../src/PyMOTW/pdb/index.rst:28
msgid ""
"The most straightforward way to use the debugger is to run it from the "
"command line, giving it your own program as input so it knows what to "
"run."
msgstr ""

#: ../../src/PyMOTW/pdb/index.rst:35
msgid ""
"Running the debugger from the command line causes it to load your source "
"file and stop execution on the first statement it finds.  In this case, "
"it stops before evaluating the definition of the class :class:`MyObj` on "
"line 7."
msgstr ""

#: ../../src/PyMOTW/pdb/index.rst:49
msgid ""
"Normally :mod:`pdb` includes the full path to each module in the output "
"when printing a filename.  In order to maintain clear examples, the "
"sample output in this section replaces the path with ``...``."
msgstr ""

#: ../../src/PyMOTW/pdb/index.rst:55
msgid "Within the Interpreter"
msgstr ""

#: ../../src/PyMOTW/pdb/index.rst:57
msgid ""
"Many Python developers work with the interactive interpreter while "
"developing early versions of modules because it lets them experiment more"
" iteratively without the save/run/repeat cycle needed when creating "
"standalone scripts.  To run the debugger from within an interactive "
"interpreter, use :func:`run` or :func:`runeval`."
msgstr ""

#: ../../src/PyMOTW/pdb/index.rst:75
msgid ""
"The argument to :func:`run` is a string expression that can be evaluated "
"by the Python interpreter.  The debugger will parse it, then pause "
"execution just before the first expression evaluates.  You can use the "
"debugger commands described below to navigate and control the execution."
msgstr ""

#: ../../src/PyMOTW/pdb/index.rst:82
msgid "From Within Your Program"
msgstr ""

#: ../../src/PyMOTW/pdb/index.rst:84
msgid ""
"Both of the previous examples assume you want to start the debugger at "
"the beginning of your program.  For a long-running process where the "
"problem appears much later in the program execution, it will be more "
"convenient to start the debugger from inside your program using "
":func:`set_trace`."
msgstr ""

#: ../../src/PyMOTW/pdb/index.rst:93
msgid ""
"Line 16 of the sample script triggers the debugger at that point in "
"execution."
msgstr ""

#: ../../src/PyMOTW/pdb/index.rst:103
msgid ""
":func:`set_trace` is just a Python function, so you can call it at any "
"point in your program.  This lets you enter the debugger based on "
"conditions inside your program, including from an exception handler or "
"via a specific branch of a control statement."
msgstr ""

#: ../../src/PyMOTW/pdb/index.rst:109
msgid "After a Failure"
msgstr ""

#: ../../src/PyMOTW/pdb/index.rst:111
msgid ""
"Debugging a failure after a program terminates is called *post-mortem* "
"debugging.  :mod:`pdb` supports post-mortem debugging through the "
":func:`pm` and :func:`post_mortem` functions."
msgstr ""

#: ../../src/PyMOTW/pdb/index.rst:118
msgid ""
"Here the incorrect attribute name on line 13 triggers an "
":ref:`AttributeError <exceptions-AttributeError>` exception, causing "
"execution to stop. :func:`pm` looks for the active traceback and starts "
"the debugger at the point in the call stack where the exception occurred."
msgstr ""

#: ../../src/PyMOTW/pdb/index.rst:145
msgid "Controlling the Debugger"
msgstr ""

#: ../../src/PyMOTW/pdb/index.rst:147
msgid ""
"You interact with the debugger using a small command language that lets "
"you move around the call stack, examine and change the values of "
"variables, and control how the debugger executes your program.  The "
"interactive debugger uses :mod:`readline` to accept commands. Entering a "
"blank line re-runs the previous command again, unless it was a "
":command:`list` operation."
msgstr ""

#: ../../src/PyMOTW/pdb/index.rst:155
msgid "Navigating the Execution Stack"
msgstr ""

#: ../../src/PyMOTW/pdb/index.rst:157
msgid ""
"At any point while the debugger is running you can use :command:`where` "
"(abbreviated :command:`w`) to find out exactly what line is being "
"executed and where on the call stack you are.  In this case, the module "
"``pdb_set_trace.py`` line 17 in the :func:`go` method."
msgstr ""

#: ../../src/PyMOTW/pdb/index.rst:174
msgid ""
"To add more context around the current location, use :command:`list` "
"(:command:`l`)."
msgstr ""

#: ../../src/PyMOTW/pdb/index.rst:193
msgid ""
"The default is to list 11 lines around the current line (five before and "
"five after).  Using :command:`list` with a single numerical argument "
"lists 11 lines around that line instead of the current line."
msgstr ""

#: ../../src/PyMOTW/pdb/index.rst:212
msgid ""
"If :command:`list` receives two arguments, it interprets them as the "
"first and last lines to include in its output."
msgstr ""

#: ../../src/PyMOTW/pdb/index.rst:234
msgid ""
"Move between frames within the current call stack using :command:`up` and"
" down.  :command:`up` (abbreviated :command:`u`) moves towards older "
"frames on the stack.  :command:`down` (abbreviated :command:`d`) moves "
"towards newer frames."
msgstr ""

#: ../../src/PyMOTW/pdb/index.rst:249
msgid ""
"Each time you move up or down the debugger prints the current location in"
" the same format as produced by :command:`where`."
msgstr ""

#: ../../src/PyMOTW/pdb/index.rst:253
msgid "Examining Variables on the Stack"
msgstr ""

#: ../../src/PyMOTW/pdb/index.rst:255
msgid ""
"Each frame on the stack maintains a set of variables, including values "
"local to the function being executed and global state information. "
":mod:`pdb` provides several ways to examine the contents of those "
"variables."
msgstr ""

#: ../../src/PyMOTW/pdb/index.rst:263
msgid ""
"The :command:`args` command (abbreviated :command:`a`) prints all of the "
"arguments to the function active in the current frame.  This example also"
" uses a recursive function to show what a deeper stack looks like when "
"printed by :command:`where`."
msgstr ""

#: ../../src/PyMOTW/pdb/index.rst:303
msgid ""
"The :command:`p` command evaluates an expression given as argument and "
"prints the result.  You can also use Python's ``print`` statement, but "
"that is passed through to the interpreter to be executed rather than "
"running as a command in the debugger."
msgstr ""

#: ../../src/PyMOTW/pdb/index.rst:316
msgid ""
"Similarly, prefixing an expression with :command:`!` passes it to the "
"Python interpreter to be evaluated.  You can use this feature to execute "
"arbitrary Python statements, including modifying variables. This example "
"changes the value of *output* before letting the debugger continue "
"running the program.  The next statement after the call to "
":func:`set_trace` prints the value of *output*, showing the modified "
"value."
msgstr ""

#: ../../src/PyMOTW/pdb/index.rst:338
msgid ""
"For more complicated values such as nested or large data structures, use "
":command:`pp` to \"pretty print\" them.  This program reads several lines"
" of text from a file."
msgstr ""

#: ../../src/PyMOTW/pdb/index.rst:345
msgid ""
"Printing the variable ``lines`` with :command:`p` results in output that "
"is difficult to read because it wraps awkwardly.  :command:`pp` uses "
":mod:`pprint` to format the value for clean printing."
msgstr ""

#: ../../src/PyMOTW/pdb/index.rst:369
msgid "Stepping Through Your Program"
msgstr ""

#: ../../src/PyMOTW/pdb/index.rst:371
msgid ""
"In addition to navigating up and down the call stack when the program is "
"paused, you can also step through execution of the program past the point"
" where it enters the debugger."
msgstr ""

#: ../../src/PyMOTW/pdb/index.rst:378
msgid ""
"Use :command:`step` to execute the current line and then stop at the next"
" execution point -- either the first statement inside a function being "
"called or the next line of the current function."
msgstr ""

#: ../../src/PyMOTW/pdb/index.rst:388
msgid ""
"The interpreter pauses at the call to :func:`set_trace` and gives control"
" to the debugger.  The first step causes the execution to enter "
":func:`f`."
msgstr ""

#: ../../src/PyMOTW/pdb/index.rst:400
msgid ""
"One more step moves execution to the first line of :func:`f` and starts "
"the loop."
msgstr ""

#: ../../src/PyMOTW/pdb/index.rst:409
msgid ""
"Stepping again moves to the first line inside the loop where ``j`` is "
"defined."
msgstr ""

#: ../../src/PyMOTW/pdb/index.rst:420
msgid ""
"The value of ``i`` is ``0``, so after one more step the value of ``j`` "
"should also be ``0``."
msgstr ""

#: ../../src/PyMOTW/pdb/index.rst:434
msgid ""
"Stepping one line at a time like this can become tedious if there is a "
"lot of code to cover before the point where the error occurs, or if the "
"same function is called repeatedly."
msgstr ""

#: ../../src/PyMOTW/pdb/index.rst:441
msgid ""
"In this example, there is nothing wrong with :func:`calc`, so stepping "
"through it each time it is called in the loop in :func:`f` obscures the "
"useful output by showing all of the lines of :func:`calc` as they are "
"executed."
msgstr ""

#: ../../src/PyMOTW/pdb/index.rst:490
msgid ""
"The :command:`next` command is like step, but does not enter functions "
"called from the statement being executed.  In effect, it steps all the "
"way through the function call to the next statement in the current "
"function in a single operation."
msgstr ""

#: ../../src/PyMOTW/pdb/index.rst:509
msgid ""
"The :command:`until` command is like :command:`next`, except it "
"explicitly continues until execution reaches a line in the same function "
"with a line number higher than the current value.  That means, for "
"example, that :command:`until` can be used to step past the end of a "
"loop."
msgstr ""

#: ../../src/PyMOTW/pdb/index.rst:548
msgid ""
"Before :command:`until` was run, the current line was 16, the last line "
"of the loop.  After :command:`until` ran, execution was on line 17, and "
"the loop had been exhausted."
msgstr ""

#: ../../src/PyMOTW/pdb/index.rst:552
msgid ""
":command:`return` is another short-cut for bypassing parts of a function."
"  It continues executing until the function is about to execute a "
"``return`` statement, and then it pauses.  This gives you time to look at"
" the return value before the function returns."
msgstr ""

#: ../../src/PyMOTW/pdb/index.rst:584
msgid "Breakpoints"
msgstr ""

#: ../../src/PyMOTW/pdb/index.rst:586
msgid ""
"As programs grow even longer, even using :command:`next` and "
":command:`until` will become slow and cumbersome.  Instead of stepping "
"through the program by hand, a better solution is to let it run normally "
"until it reaches a point where you want the debugger to interrupt it.  "
"You could use :func:`set_trace` to start the debugger, but that only "
"works if there is only one point you want to pause the program.  It is "
"more convenient to run the program through the debugger, but tell the "
"debugger where to stop in advance using *breakpoints*.  The debugger "
"monitors your program, and when it reaches the location described by a "
"breakpoint the program is paused before the line is executed."
msgstr ""

#: ../../src/PyMOTW/pdb/index.rst:601
msgid ""
"There are several options to the :command:`break` command used for "
"setting break points.  You can specify the line number, file, and "
"function where processing should pause.  To set a breakpoint on a "
"specific line of the current file, use ``break lineno``:"
msgstr ""

#: ../../src/PyMOTW/pdb/index.rst:624
msgid ""
"The command :command:`continue` tells the debugger to keep running your "
"program until the next breakpoint.  In this case, it runs through the "
"first iteration of the ``for`` loop in :func:`f` and stops inside "
":func:`calc` during the second iteration."
msgstr ""

#: ../../src/PyMOTW/pdb/index.rst:629
msgid ""
"Breakpoints can also be set to the first line of a function by specifying"
" the function name instead of a line number.  This example shows what "
"happens if a breakpoint is added for the :func:`calc` function."
msgstr ""

#: ../../src/PyMOTW/pdb/index.rst:657
msgid ""
"To specify a breakpoint in another file, prefix the line or function "
"argument with a filename."
msgstr ""

#: ../../src/PyMOTW/pdb/index.rst:663
msgid ""
"Here a breakpoint is set for line 11 of ``pdb_break.py`` after starting "
"the main program ``pdb_break_remote.py``."
msgstr ""

#: ../../src/PyMOTW/pdb/index.rst:684
msgid ""
"The filename can be a full path to the source file, or a relative path to"
" a file available on ``sys.path``."
msgstr ""

#: ../../src/PyMOTW/pdb/index.rst:687
msgid ""
"To list the breakpoints currently set, use :command:`break` without any "
"arguments.  The output includes the file and line number of each break "
"point, as well as information about how many times it has been "
"encountered."
msgstr ""

#: ../../src/PyMOTW/pdb/index.rst:727
msgid "Managing Breakpoints"
msgstr ""

#: ../../src/PyMOTW/pdb/index.rst:729
msgid ""
"As each new breakpoint is added, it is assigned a numerical identifier.  "
"These ID numbers are used to enable, disable, and remove the breakpoints "
"interactively."
msgstr ""

#: ../../src/PyMOTW/pdb/index.rst:733
msgid ""
"Turning off a breakpoint with :command:`disable` tells the debugger not "
"to stop when that line is reached.  The breakpoint is remembered, but "
"ignored."
msgstr ""

#: ../../src/PyMOTW/pdb/index.rst:770
msgid ""
"The debugging session below sets two breakpoints in the program, then "
"disables one.  The program is run until the remaining breakpoint is "
"encountered, and then the other breakpoint is turned back on with "
":command:`enable` before execution continues."
msgstr ""

#: ../../src/PyMOTW/pdb/index.rst:849
msgid ""
"The lines prefixed with ``B`` in the output from :command:`list` show "
"where the breakpoints are set in the program (lines 9 and 18)."
msgstr ""

#: ../../src/PyMOTW/pdb/index.rst:852
msgid "Use :command:`clear` to delete a breakpoint entirely."
msgstr ""

#: ../../src/PyMOTW/pdb/index.rst:884
msgid ""
"The other breakpoints retain their original identifiers and are not "
"renumbered."
msgstr ""

#: ../../src/PyMOTW/pdb/index.rst:888
msgid "Temporary Breakpoints"
msgstr ""

#: ../../src/PyMOTW/pdb/index.rst:890
msgid ""
"A temporary breakpoint is automatically cleared the first time program "
"execution hits it.  Using a temporary breakpoint lets you reach a "
"particular spot in the program flow quickly, just as with a regular "
"breakpoint, but since it is cleared immediately it does not interfere "
"with subsequent progress if that part of the program is run repeatedly."
msgstr ""

#: ../../src/PyMOTW/pdb/index.rst:933
msgid ""
"After the program reaches line 11 the first time, the breakpoint is "
"removed and execution does not stop again until the program finishes."
msgstr ""

#: ../../src/PyMOTW/pdb/index.rst:937
msgid "Conditional Breakpoints"
msgstr ""

#: ../../src/PyMOTW/pdb/index.rst:939
msgid ""
"Rules can be applied to breakpoints so that execution only stops when the"
" conditions are met.  Using conditional breakpoints gives you finer "
"control over how the debugger pauses your program than manually enabling "
"and disabling breakpoints yourself."
msgstr ""

#: ../../src/PyMOTW/pdb/index.rst:944
msgid ""
"Conditional breakpoints can be set in two ways.  The first is to specify "
"the condition when the breakpoint is set using :command:`break`."
msgstr ""

#: ../../src/PyMOTW/pdb/index.rst:970
msgid ""
"The condition argument must be an expression using values visible in the "
"stack frame where the breakpoint is defined.  If the expression evaluates"
" as true, execution stops at the breakpoint."
msgstr ""

#: ../../src/PyMOTW/pdb/index.rst:974
msgid ""
"A condition can also be applied to an existing breakpoint using the "
":command:`condition` command.  The arguments are the breakpoint ID and "
"the expression."
msgstr ""

#: ../../src/PyMOTW/pdb/index.rst:1000
msgid "Ignoring Breakpoints"
msgstr ""

#: ../../src/PyMOTW/pdb/index.rst:1002
msgid ""
"Programs with a lot of looping or recursive calls to the same function "
"are often easier to debug by \"skipping ahead\" in the execution, instead"
" of watching every call or breakpoint.  The :command:`ignore` command "
"tells the debugger to pass over a breakpoint without stopping. Each time "
"processing encounteres the breakpoint, it decrements the ignore counter."
"  When the counter is zero, the breakpoint is re-activated."
msgstr ""

#: ../../src/PyMOTW/pdb/index.rst:1053
msgid ""
"Explicitly resetting the ignore count to zero re-enables the breakpoint "
"immediately."
msgstr ""

#: ../../src/PyMOTW/pdb/index.rst:1080
msgid "Triggering Actions on a Breakpoint"
msgstr ""

#: ../../src/PyMOTW/pdb/index.rst:1082
msgid ""
"In addition to the purely interactive mode, :mod:`pdb` supports basic "
"scripting.  Using :command:`commands`, you can define a series of "
"interpreter commands, including Python statements, to be executed when a "
"specific breakpoint is encountered.  After running :command:`commands` "
"with the breakpoint number as argument, the debugger prompt changes to "
"``(com)``.  Enter commands one a time, and finish the list with ``end`` "
"to save the script and return to the main debugger prompt."
msgstr ""

#: ../../src/PyMOTW/pdb/index.rst:1124
msgid ""
"This feature is especially useful for debugging code that uses a lot of "
"data structures or variables, since you can have the debugger print out "
"all of the values automatically, instead of doing it manually each time "
"the breakpoint is encountered."
msgstr ""

#: ../../src/PyMOTW/pdb/index.rst:1130
msgid "Changing Execution Flow"
msgstr ""

#: ../../src/PyMOTW/pdb/index.rst:1132
msgid ""
"The :command:`jump` command lets you alter the flow of your program at "
"runtime, without modifying the code.  You can skip forwards to avoid "
"running some code, or backwards to run it again.  This sample program "
"generates a list of numbers."
msgstr ""

#: ../../src/PyMOTW/pdb/index.rst:1140
msgid ""
"When run without interference the output is a sequence of increasing "
"numbers divisible by ``5``."
msgstr ""

#: ../../src/PyMOTW/pdb/index.rst:1156
msgid "Jump Ahead"
msgstr ""

#: ../../src/PyMOTW/pdb/index.rst:1158
msgid ""
"Jumping ahead moves the point of execution past the current location "
"without evaluating any of the statements in between.  By skipping over "
"line 13 in the example below, the value of ``j`` is not incremented and "
"all of the subsequent values that depend on it are a little smaller."
msgstr ""

#: ../../src/PyMOTW/pdb/index.rst:1208
msgid "Jump Back"
msgstr ""

#: ../../src/PyMOTW/pdb/index.rst:1210
msgid ""
"Jumps can also move the program execution to a statement that has already"
" been executed, to run it again.  Here, the value of ``j`` is incremented"
" an extra time, so the numbers in the result sequence are all larger than"
" they would otherwise be."
msgstr ""

#: ../../src/PyMOTW/pdb/index.rst:1252
msgid "Illegal Jumps"
msgstr ""

#: ../../src/PyMOTW/pdb/index.rst:1254
msgid ""
"Jumping in and out of certain flow control statements is dangerous or "
"undefined, and therefore prevented by the debugger."
msgstr ""

#: ../../src/PyMOTW/pdb/index.rst:1260
msgid ""
"You can jump into a function, but if you do the arguments are not defined"
" and the code is unlikely to work."
msgstr ""

#: ../../src/PyMOTW/pdb/index.rst:1282
msgid ""
"You cannot jump into the middle of a block such as a ``for`` loop or "
"``try:except`` statement."
msgstr ""

#: ../../src/PyMOTW/pdb/index.rst:1302
msgid ""
"The code in a ``finally`` block must all be executed, so you cannot jump "
"out of the block."
msgstr ""

#: ../../src/PyMOTW/pdb/index.rst:1323
msgid ""
"And the most basic restriction is that jumping is constrained to the "
"bottom frame on the call stack.  If you move up the stack to examine "
"variables, you cannot change the execution flow at that point."
msgstr ""

#: ../../src/PyMOTW/pdb/index.rst:1359
msgid "Restarting Your Program"
msgstr ""

#: ../../src/PyMOTW/pdb/index.rst:1361
msgid ""
"When the debugger reaches the end of your program, it automatically "
"starts it over, but you can also restart it explicitly without leaving "
"the debugger and losing your breakpoints or other settings."
msgstr ""

#: ../../src/PyMOTW/pdb/index.rst:1368
msgid ""
"Running the above program to completion within the debugger prints the "
"name of the script file, since no other arguments were given on the "
"command line."
msgstr ""

#: ../../src/PyMOTW/pdb/index.rst:1386
msgid ""
"The program can be restarted using :command:`run`.  Arguments passed to "
":command:`run` are parsed with :mod:`shlex` and passed to the program as "
"though they were command line arguments, so you can restart the program "
"with different settings."
msgstr ""

#: ../../src/PyMOTW/pdb/index.rst:1407
msgid ""
":command:`run` can also be used at any other point in processing to "
"restart the program."
msgstr ""

#: ../../src/PyMOTW/pdb/index.rst:1432
msgid "Customizing the Debugger with Aliases"
msgstr ""

#: ../../src/PyMOTW/pdb/index.rst:1434
msgid ""
"You can avoid typing complex commands repeatedly by using "
":command:`alias` to define a shortcut.  Alias expansion is applied to the"
" first word of each command.  The body of the alias can consist of any "
"command that is legal to type at the debugger prompt, including other "
"debugger commands and pure Python expressions.  Recursion is allowed in "
"alias definitions, so one alias can even invoke another."
msgstr ""

#: ../../src/PyMOTW/pdb/index.rst:1461
msgid ""
"Running :command:`alias` without any arguments shows the list of defined "
"aliases.  A single argument is assumed to be the name of an alias, and "
"its definition is printed."
msgstr ""

#: ../../src/PyMOTW/pdb/index.rst:1474
msgid ""
"Arguments to the alias are referenced using ``%n`` where *n* is replaced "
"with a number indicating the position of the argument, starting with "
"``1``.  To consume all of the arguments, use ``%*``."
msgstr ""

#: ../../src/PyMOTW/pdb/index.rst:1493
msgid "Clear the definition of an alias with :command:`unalias`."
msgstr ""

#: ../../src/PyMOTW/pdb/index.rst:1506
msgid "Saving Configuration Settings"
msgstr ""

#: ../../src/PyMOTW/pdb/index.rst:1508
msgid ""
"Debugging a program involves a lot of repetition; running the code, "
"observing the output, adjusting the code or inputs, and running it again."
"  :mod:`pdb` attempts to cut down on the amount of repetition you need to"
" use to control the debugging experience, to let you concentrate on your "
"code instead of the debugger.  To help reduce the number of times you "
"issue the same commands to the debugger, :mod:`pdb` lets you save "
"configuration using text files read and interpreted on startup."
msgstr ""

#: ../../src/PyMOTW/pdb/index.rst:1517
msgid ""
"The file ``~/.pdbrc`` is read first, allowing you to set global personal "
"preferences for all of your debugging sessions.  Then ``./.pdbrc`` is "
"read from the current working directory, so you can set local preferences"
" for a particular project."
msgstr ""

#: ../../src/PyMOTW/pdb/index.rst:1550
msgid ""
"Any configuration commands that can be typed at the debugger prompt can "
"be saved in one of the startup files, but most commands that control the "
"execution (:command:`continue`, :command:`jump`, etc.) cannot.  The "
"exception is :command:`run`, which means you can set the command line "
"arguments for a debugging session in ``./.pdbrc`` so they are consistent "
"across several runs."
msgstr ""

#: ../../src/PyMOTW/pdb/index.rst:1560
msgid "`pdb <http://docs.python.org/library/pdb.html>`_"
msgstr ""

#: ../../src/PyMOTW/pdb/index.rst:1560
msgid "The standard library documentation for this module."
msgstr ""

#: ../../src/PyMOTW/pdb/index.rst:1563
msgid ":mod:`readline`"
msgstr ""

#: ../../src/PyMOTW/pdb/index.rst:1563
msgid "Interactive prompt editing library."
msgstr ""

#: ../../src/PyMOTW/pdb/index.rst:1566
msgid ":mod:`cmd`"
msgstr ""

#: ../../src/PyMOTW/pdb/index.rst:1566
msgid "Build interactive programs."
msgstr ""

#: ../../src/PyMOTW/pdb/index.rst:1568
msgid ":mod:`shlex`"
msgstr ""

#: ../../src/PyMOTW/pdb/index.rst:1569
msgid "Shell command line parsing."
msgstr ""

