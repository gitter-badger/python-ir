# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2016, Python-ir.org
# This file is distributed under the same license as the Python-ir package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2016.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python-ir 0.1\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2016-05-07 20:31+0430\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.3.4\n"

#: ../../src/PyMOTW/signal/index.rst:3
msgid "signal -- Receive notification of asynchronous system events"
msgstr ""

#: ../../src/PyMOTW/signal/index.rst:8
msgid "Receive notification of asynchronous system events"
msgstr ""

#: ../../src/PyMOTW/signal/index.rst:9
msgid "1.4 and later"
msgstr ""

#: ../../src/PyMOTW/signal/index.rst:13
msgid ""
"Programming with Unix signal handlers is a non-trivial endeavor. This is "
"an introduction, and does not include all of the details you may need to "
"use signals successfully on every platform. There is some degree of "
"standardization across versions of Unix, but there is also some "
"variation, so consult documentation for your OS if you run into trouble."
msgstr ""

#: ../../src/PyMOTW/signal/index.rst:18
msgid ""
"Signals are an operating system feature that provide a means of notifying"
" your program of an event, and having it handled asynchronously.  They "
"can be generated by the system itself, or sent from one process to "
"another.  Since signals interrupt the regular flow of your program, it is"
" possible that some operations (especially I/O) may produce error if a "
"signal is received in the middle."
msgstr ""

#: ../../src/PyMOTW/signal/index.rst:25
msgid ""
"Signals are identified by integers and are defined in the operating "
"system C headers.  Python exposes the signals appropriate for the "
"platform as symbols in the :mod:`signal` module.  For the examples below,"
" I will use ``SIGINT`` and ``SIGUSR1``.  Both are typically defined for "
"all Unix and Unix-like systems."
msgstr ""

#: ../../src/PyMOTW/signal/index.rst:32
msgid "Receiving Signals"
msgstr ""

#: ../../src/PyMOTW/signal/index.rst:34
msgid ""
"As with other forms of event-based programming, signals are received by "
"establishing a callback function, called a *signal handler*, that is "
"invoked when the signal occurs.  The arguments to your signal handler are"
" the signal number and the stack frame from the point in your program "
"that was interrupted by the signal."
msgstr ""

#: ../../src/PyMOTW/signal/index.rst:44
msgid ""
"This relatively simple example script loops indefinitely, pausing for a "
"few seconds each time.  When a signal comes in, the sleep call is "
"interrupted and the signal handler ``receive_signal()`` prints the signal"
" number.  When the signal handler returns, the loop continues."
msgstr ""

#: ../../src/PyMOTW/signal/index.rst:49
msgid ""
"To send signals to the running program, I use the command line program "
"kill.  To produce the output below, I ran ``signal_signal.py`` in one "
"window, then ``kill -USR1 $pid``, ``kill -USR2 $pid``, and ``kill -INT "
"$pid`` in another."
msgstr ""

#: ../../src/PyMOTW/signal/index.rst:74
msgid "getsignal()"
msgstr ""

#: ../../src/PyMOTW/signal/index.rst:76
msgid ""
"To see what signal handlers are registered for a signal, use "
":func:`getsignal()`.  Pass the signal number as argument.  The return "
"value is the registered handler, or one of the special values "
"``signal.SIG_IGN`` (if the signal is being ignored), ``signal.SIG_DFL`` "
"(if the default behavior is being used), or ``None`` (if the existing "
"signal handler was registered from C, rather than Python)."
msgstr ""

#: ../../src/PyMOTW/signal/index.rst:88
msgid ""
"Again, since each OS may have different signals defined, the output you "
"see from running this on other systems may vary.  This is from OS X:"
msgstr ""

#: ../../src/PyMOTW/signal/index.rst:129
msgid "Sending Signals"
msgstr ""

#: ../../src/PyMOTW/signal/index.rst:131
msgid ""
"The function for sending signals is ``os.kill()``.  Its use is covered in"
" the section on the :mod:`os` module, :ref:`creating-processes-with-os-"
"fork`."
msgstr ""

#: ../../src/PyMOTW/signal/index.rst:136
msgid "Alarms"
msgstr ""

#: ../../src/PyMOTW/signal/index.rst:138
msgid ""
"Alarms are a special sort of signal, where your program asks the OS to "
"notify it after some period of time has elapsed.  As `the standard module"
" documentation for os <http://docs.python.org/lib/node545.html>`_ points "
"out, this is useful for avoiding blocking indefinitely on an I/O "
"operation or other system call."
msgstr ""

#: ../../src/PyMOTW/signal/index.rst:149
msgid ""
"In this example, the call to :func:`sleep()` does not last the full 4 "
"seconds."
msgstr ""

#: ../../src/PyMOTW/signal/index.rst:161
msgid "Ignoring Signals"
msgstr ""

#: ../../src/PyMOTW/signal/index.rst:163
msgid ""
"To ignore a signal, register ``SIG_IGN`` as the handler.  This script "
"replaces the default handler for ``SIGINT`` with ``SIG_IGN``, and "
"registers a handler for ``SIGUSR1``.  Then it uses :func:`signal.pause()`"
" to wait for a signal to be received."
msgstr ""

#: ../../src/PyMOTW/signal/index.rst:172
msgid ""
"Normally ``SIGINT`` (the signal sent by the shell to your program when "
"you hit Ctrl-C) raises a :ref:`KeyboardInterrupt <exceptions-"
"KeyboardInterrupt>`.  In this example, we ignore ``SIGINT`` and raise "
":ref:`SystemExit <exceptions-SystemExit>` when we see ``SIGUSR1``.  Each "
"``^C`` represents an attempt to use Ctrl-C to kill the script from the "
"terminal.  Using ``kill -USR1 72598`` from another terminal eventually "
"causes the script to exit."
msgstr ""

#: ../../src/PyMOTW/signal/index.rst:188
msgid "Signals and Threads"
msgstr ""

#: ../../src/PyMOTW/signal/index.rst:190
msgid ""
"Signals and threads don't generally mix well because only the main thread"
" of a process will receive signals.  The following example sets up a "
"signal handler, waits for the signal in one thread, and sends the signal "
"from another."
msgstr ""

#: ../../src/PyMOTW/signal/index.rst:199
msgid ""
"Notice that the signal handlers were all registered in the main thread.  "
"This is a requirement of the signal module implementation for Python, "
"regardless of underlying platform support for mixing threads and signals."
"  Although the receiver thread calls :func:`signal.pause()`, it does not "
"receive the signal.  The ``signal.alarm(2)`` call near the end of the "
"example prevents an infinite block, since the receiver thread will never "
"exit."
msgstr ""

#: ../../src/PyMOTW/signal/index.rst:216
msgid ""
"Although alarms can be set in threads, they are also received by the main"
" thread."
msgstr ""

#: ../../src/PyMOTW/signal/index.rst:223
msgid ""
"Notice that the alarm does not abort the :func:`sleep()` call in "
":func:`use_alarm()`."
msgstr ""

#: ../../src/PyMOTW/signal/index.rst:239
msgid "`signal <http://docs.python.org/lib/module-signal.html>`_"
msgstr ""

#: ../../src/PyMOTW/signal/index.rst:239
msgid "Standard library documentation for this module."
msgstr ""

#: ../../src/PyMOTW/signal/index.rst:242
msgid ":ref:`creating-processes-with-os-fork`"
msgstr ""

#: ../../src/PyMOTW/signal/index.rst:242
msgid "The :func:`kill()` function can be used to send signals between processes."
msgstr ""

