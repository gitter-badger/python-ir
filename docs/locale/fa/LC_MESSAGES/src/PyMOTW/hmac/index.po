# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2016, Python-ir.org
# This file is distributed under the same license as the Python-ir package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2016.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python-ir 0.1\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2016-05-07 20:31+0430\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.3.4\n"

#: ../../src/PyMOTW/hmac/index.rst:3
msgid "hmac -- Cryptographic signature and verification of messages."
msgstr ""

#: ../../src/PyMOTW/hmac/index.rst:9
msgid ""
"The hmac module implements keyed-hashing for message authentication, as "
"described in :rfc:`2104`."
msgstr ""

#: ../../src/PyMOTW/hmac/index.rst:11
msgid "2.2"
msgstr ""

#: ../../src/PyMOTW/hmac/index.rst:13
msgid ""
"The HMAC algorithm can be used to verify the integrity of information "
"passed between applications or stored in a potentially vulnerable "
"location. The basic idea is to generate a cryptographic hash of the "
"actual data combined with a shared secret key. The resulting hash can "
"then be used to check the transmitted or stored message to determine a "
"level of trust, without transmitting the secret key."
msgstr ""

#: ../../src/PyMOTW/hmac/index.rst:20
msgid ""
"Disclaimer: I'm not a security expert. For the full details on HMAC, "
"check out :rfc:`2104`."
msgstr ""

#: ../../src/PyMOTW/hmac/index.rst:24
msgid "Example"
msgstr ""

#: ../../src/PyMOTW/hmac/index.rst:26
msgid ""
"Creating the hash is not complex. Here's a simple example which uses the "
"default MD5 hash algorithm:"
msgstr ""

#: ../../src/PyMOTW/hmac/index.rst:33
msgid ""
"When run, the code reads its source file and computes an HMAC signature "
"for it:"
msgstr ""

#: ../../src/PyMOTW/hmac/index.rst:50
msgid ""
"If I haven't changed the file by the time I release the example source "
"for this week, the copy you download should produce the same hash."
msgstr ""

#: ../../src/PyMOTW/hmac/index.rst:55
msgid "SHA vs. MD5"
msgstr ""

#: ../../src/PyMOTW/hmac/index.rst:57
msgid ""
"Although the default cryptographic algorithm for :mod:`hmac` is MD5, that"
" is not the most secure method to use. MD5 hashes have some weaknesses, "
"such as collisions (where two different messages produce the same hash). "
"The SHA-1 algorithm is considered to be stronger, and should be used "
"instead."
msgstr ""

#: ../../src/PyMOTW/hmac/index.rst:67
msgid ""
"``hmac.new()`` takes 3 arguments. The first is the secret key, which "
"should be shared between the two endpoints which are communicating so "
"both ends can use the same value. The second value is an initial message."
" If the message content that needs to be authenticated is small, such as "
"a timestamp or HTTP POST, the entire body of the message can be passed to"
" ``new()`` instead of using the update() method. The last argument is the"
" digest module to be used. The default is ``hashlib.md5``. The previous "
"example substitutes ``hashlib.sha1``."
msgstr ""

#: ../../src/PyMOTW/hmac/index.rst:89
msgid "Binary Digests"
msgstr ""

#: ../../src/PyMOTW/hmac/index.rst:91
msgid ""
"The first few examples used the ``hexdigest()`` method to produce "
"printable digests. The hexdigest is is a different representation of the "
"value calculated by the ``digest()`` method, which is a binary value that"
" may include unprintable or non-ASCII characters, including NULs. Some "
"web services (Google checkout, Amazon S3) use the ``base64`` encoded "
"version of the binary digest instead of the hexdigest."
msgstr ""

#: ../../src/PyMOTW/hmac/index.rst:103
msgid ""
"The base64 encoded string ends in a newline, which frequently needs to be"
" stripped off when embedding the string in HTTP headers or other "
"formatting-sensitive contexts."
msgstr ""

#: ../../src/PyMOTW/hmac/index.rst:122
msgid "Applications"
msgstr ""

#: ../../src/PyMOTW/hmac/index.rst:124
msgid ""
"HMAC authentication should be used for any public network service, and "
"any time data is stored where security is important. For example, when "
"sending data through a pipe or socket, that data should be signed and "
"then the signature should be tested before the data is used. The extended"
" example below is available in the ``hmac_pickle.py`` file as part of the"
" PyMOTW source package."
msgstr ""

#: ../../src/PyMOTW/hmac/index.rst:131
msgid ""
"First, let's establish a function to calculate a digest for a string, and"
" a simple class to be instantiated and passed through a communication "
"channel."
msgstr ""

#: ../../src/PyMOTW/hmac/index.rst:159
msgid ""
"Next, create a :mod:`StringIO` buffer to represent the socket or pipe. We"
" will using a naive, but easy to parse, format for the data stream. The "
"digest and length of the data are written, followed by a new line. The "
"serialized representation of the object, generated by :mod:`pickle`, "
"follows. In a real system, we would not want to depend on a length value,"
" since if the digest is wrong the length is probably wrong as well. Some "
"sort of terminator sequence not likely to appear in the real data would "
"be more appropriate."
msgstr ""

#: ../../src/PyMOTW/hmac/index.rst:168
msgid ""
"For this example, we will write two objects to the stream. The first is "
"written using the correct digest value."
msgstr ""

#: ../../src/PyMOTW/hmac/index.rst:186
msgid ""
"The second object is written to the stream with an invalid digest, "
"produced by calculating the digest for some other data instead of the "
"pickle."
msgstr ""

#: ../../src/PyMOTW/hmac/index.rst:203
msgid ""
"Now that the data is in the :mod:`StringIO` buffer, we can read it back "
"out again.  The first step is to read the line of data with the digest "
"and data length.  Then the remaining data is read (using the length "
"value). We could use ``pickle.load()`` to read directly from the stream, "
"but that assumes a trusted data stream and we do not yet trust the data "
"enough to unpickle it. Reading the pickle as a string collect the data "
"from the stream, without actually unpickling the object."
msgstr ""

#: ../../src/PyMOTW/hmac/index.rst:227
msgid ""
"Once we have the pickled data, we can recalculate the digest value and "
"compare it against what we read. If the digests match, we know it is safe"
" to trust the data and unpickle it."
msgstr ""

#: ../../src/PyMOTW/hmac/index.rst:242
msgid ""
"The output shows that the first object is verified and the second is "
"deemed \"corrupted\", as expected:"
msgstr ""

#: ../../src/PyMOTW/hmac/index.rst:272
msgid "`hmac <http://docs.python.org/library/hmac.html>`_"
msgstr ""

#: ../../src/PyMOTW/hmac/index.rst:272
msgid "The standard library documentation for this module."
msgstr ""

#: ../../src/PyMOTW/hmac/index.rst:275
msgid ":rfc:`2104`"
msgstr ""

#: ../../src/PyMOTW/hmac/index.rst:275
msgid "HMAC: Keyed-Hashing for Message Authentication"
msgstr ""

#: ../../src/PyMOTW/hmac/index.rst:278
msgid ":mod:`hashlib`"
msgstr ""

#: ../../src/PyMOTW/hmac/index.rst:278
msgid "The :mod:`hashlib` module."
msgstr ""

#: ../../src/PyMOTW/hmac/index.rst:281
msgid ":mod:`pickle`"
msgstr ""

#: ../../src/PyMOTW/hmac/index.rst:281
msgid "Serialization library."
msgstr ""

#: ../../src/PyMOTW/hmac/index.rst:284
msgid "`WikiPedia: MD5 <http://en.wikipedia.org/wiki/MD5>`_"
msgstr ""

#: ../../src/PyMOTW/hmac/index.rst:284
msgid "Description of the MD5 hashing algorithm."
msgstr ""

#: ../../src/PyMOTW/hmac/index.rst:286
msgid ""
"`Authenticating to Amazon S3 Web Service "
"<http://docs.amazonwebservices.com/AmazonS3/2006-03-01/index.html?S3_Authentication.html>`_"
msgstr ""

#: ../../src/PyMOTW/hmac/index.rst:287
msgid "Instructions for authenticating to S3 using HMAC-SHA1 signed credentials."
msgstr ""

