# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2016, Python-ir.org
# This file is distributed under the same license as the Python-ir package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2016.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python-ir 0.1\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2016-05-07 20:31+0430\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.3.4\n"

#: ../../src/PyMOTW/gc/index.rst:3
msgid "gc -- Garbage Collector"
msgstr ""

#: ../../src/PyMOTW/gc/index.rst:8
msgid "Manages memory used by Python objects"
msgstr ""

#: ../../src/PyMOTW/gc/index.rst:9
msgid "2.1+"
msgstr ""

#: ../../src/PyMOTW/gc/index.rst:11
msgid ""
":mod:`gc` exposes the underlying memory management mechanism of Python, "
"the automatic garbage collector.  The module includes functions for "
"controlling how the collector operates and to examine the objects known "
"to the system, either pending collection or stuck in reference cycles and"
" unable to be freed."
msgstr ""

#: ../../src/PyMOTW/gc/index.rst:18
msgid "Tracing References"
msgstr ""

#: ../../src/PyMOTW/gc/index.rst:20
msgid ""
"With :mod:`gc` you can use the incoming and outgoing references between "
"objects to find cycles in complex data structures.  If you know the data "
"structure with the cycle, you can construct custom code to examine its "
"properties.  If not, you can the :func:`get_referents()` and "
":func:`get_referrers()` functions to build generic debugging tools."
msgstr ""

#: ../../src/PyMOTW/gc/index.rst:27
msgid ""
"For example, :func:`get_referents()` shows the objects *referred to* by "
"the input arguments."
msgstr ""

#: ../../src/PyMOTW/gc/index.rst:34
msgid ""
"In this case, the :class:`Graph` instance ``three`` holds references to "
"its instance dictionary (in the ``__dict__`` attribute) and its class."
msgstr ""

#: ../../src/PyMOTW/gc/index.rst:56
msgid ""
"This example uses a :mod:`Queue` to perform a breadth-first traversal of "
"all of the object references looking for cycles.  The items inserted into"
" the queue are tuples containing the reference chain so far and the next "
"object to examine.  It starts with ``three``, and look at everything it "
"refers to.  Skipping classes lets us avoid looking at methods, modules, "
"etc."
msgstr ""

#: ../../src/PyMOTW/gc/index.rst:67
msgid ""
"The cycle in the nodes is easily found by watching for objects that have "
"already been processed.  To avoid holding references to those objects, "
"their :func:`id()` values are cached in a set.  The dictionary objects "
"found in the cycle are the ``__dict__`` values for the :class:`Graph` "
"instances, and hold their instance attributes."
msgstr ""

#: ../../src/PyMOTW/gc/index.rst:104
msgid "Forcing Garbage Collection"
msgstr ""

#: ../../src/PyMOTW/gc/index.rst:106
msgid ""
"Although the garbage collector runs automatically as the interpreter "
"executes your program, you may want to trigger collection to run at a "
"specific time when you know there are a lot of objects to free or there "
"is not much work happening in your application.  Trigger collection using"
" :func:`collect()`."
msgstr ""

#: ../../src/PyMOTW/gc/index.rst:116
msgid ""
"In this example, the cycle is cleared as soon as collection runs the "
"first time, since nothing refers to the :class:`Graph` nodes except "
"themselves.  :func:`collect()` returns the number of \"unreachable\" "
"objects it found.  In this case, the value is ``6`` because there are 3 "
"objects with their instance attribute dictionaries."
msgstr ""

#: ../../src/PyMOTW/gc/index.rst:145
msgid ""
"If :class:`Graph` has a :func:`__del__()` method, however, the garbage "
"collector cannot break the cycle."
msgstr ""

#: ../../src/PyMOTW/gc/index.rst:152
msgid ""
"Because more than one object in the cycle has a finalizer method, the "
"order in which the objects need to be finalized and then garbage "
"collected cannot be determined, so the garbage collector plays it safe "
"and keeps the objects."
msgstr ""

#: ../../src/PyMOTW/gc/index.rst:174
msgid "When the cycle is broken, the :class:`Graph` instances can be collected."
msgstr ""

#: ../../src/PyMOTW/gc/index.rst:181
msgid ""
"Because ``gc.garbage`` holds a reference to the objects from the previous"
" garbage collection run, it needs to be cleared out after the cycle is "
"broken to reduce the reference counts so they can be finalized and freed."
msgstr ""

#: ../../src/PyMOTW/gc/index.rst:217
msgid "Finding References to Objects that Can't be Collected"
msgstr ""

#: ../../src/PyMOTW/gc/index.rst:219
msgid ""
"Looking for the object holding a reference to something in the garbage is"
" a little trickier than seeing what an object references.  Because the "
"code asking about the reference needs to hold a reference itself, some of"
" the referrers need to be ignored.  This example creates a graph cycle, "
"then works through the :class:`Graph` instances in the garbage and "
"removes the reference in the \"parent\" node."
msgstr ""

#: ../../src/PyMOTW/gc/index.rst:230
msgid ""
"This sort of logic is overkill if you understand why the cycles are being"
" created in the first place, but if you have an unexplained cycle in your"
" data using :func:`get_referrers()` can expose the unexpected "
"relationship."
msgstr ""

#: ../../src/PyMOTW/gc/index.rst:275
msgid "Collection Thresholds and Generations"
msgstr ""

#: ../../src/PyMOTW/gc/index.rst:277
msgid ""
"The garbage collector maintains three lists of objects it sees as it "
"runs, one for each \"generation\" tracked by the collector.  As objects "
"are examined in each generation, they are either collected or they age "
"into subsequent generations until they finally reach the stage where they"
" are kept permanently."
msgstr ""

#: ../../src/PyMOTW/gc/index.rst:283
msgid ""
"The collector routines can be tuned to occur at different frequencies "
"based on the difference between the number of object allocations and "
"deallocations between runs.  When the number of allocations minus the "
"number of deallocations is greater than the threshold for the generation,"
" the garbage collector is run.  The current thresholds can be examined "
"with :func:`get_threshold()`."
msgstr ""

#: ../../src/PyMOTW/gc/index.rst:294
msgid "The return value is a tuple with the threshold for each generation."
msgstr ""

#: ../../src/PyMOTW/gc/index.rst:308
msgid ""
"The thresholds can be changed with :func:`set_threshold()`.  This example"
" program reads the threshold for generation ``0`` from the command line, "
"adjusts the :mod:`gc` settings, then allocates a series of objects."
msgstr ""

#: ../../src/PyMOTW/gc/index.rst:317
msgid ""
"Different threshold values introduce the garbage collection sweeps at "
"different times, shown here because debugging is enabled."
msgstr ""

#: ../../src/PyMOTW/gc/index.rst:357
msgid "A smaller threshold causes the sweeps to run more frequently."
msgstr ""

#: ../../src/PyMOTW/gc/index.rst:408
msgid "Debugging"
msgstr ""

#: ../../src/PyMOTW/gc/index.rst:410
msgid ""
"Debugging memory leaks can be challenging.  :mod:`gc` includes several "
"options to expose the inner workings to make the job easier.  The options"
" are bit-flags meant to be combined and passed to :func:`set_debug()` to "
"configure the garbage collector while your program is running.  Debugging"
" information is printed to :ref:`stderr <sys-input-output>`."
msgstr ""

#: ../../src/PyMOTW/gc/index.rst:417
msgid ""
"The :const:`DEBUG_STATS` flag turns on statistics reporting, causing the "
"garbage collector to report when it is running, the number of objects "
"tracked for each generation, and the amount of time it took to perform "
"the sweep."
msgstr ""

#: ../../src/PyMOTW/gc/index.rst:426
msgid ""
"This example output shows two separate runs of the collector because it "
"runs once when it is invoked explicitly, and a second time when the "
"interpreter exits."
msgstr ""

#: ../../src/PyMOTW/gc/index.rst:447
msgid ""
"Enabling :const:`DEBUG_COLLECTABLE` and :const:`DEBUG_UNCOLLECTABLE` "
"causes the collector to report on whether each object it examines can or "
"cannot be collected.  You need to combine these flags need with "
":const:`DEBUG_OBJECTS` so :mod:`gc` will print information about the "
"objects being held."
msgstr ""

#: ../../src/PyMOTW/gc/index.rst:457
msgid ""
"The two classes :class:`Graph` and :class:`CleanupGraph` are constructed "
"so it is possible to create structures that are automatically collectable"
" and structures where cycles need to be explicitly broken by the user."
msgstr ""

#: ../../src/PyMOTW/gc/index.rst:462
msgid ""
"The output shows that the :class:`Graph` instances :obj:`one` and "
":obj:`two` create a cycle, but are still collectable because they do not "
"have a finalizer and their only incoming references are from other "
"objects that can be collected.  Although :class:`CleanupGraph` has a "
"finalizer, :obj:`three` is reclaimed as soon as its reference count goes "
"to zero. In contrast, :obj:`four` and :obj:`five` create a cycle and "
"cannot be freed."
msgstr ""

#: ../../src/PyMOTW/gc/index.rst:502
msgid ""
"The flag :const:`DEBUG_INSTANCES` works much the same way for instances "
"of old-style classes (not derived from :class:`object`."
msgstr ""

#: ../../src/PyMOTW/gc/index.rst:509
msgid ""
"In this case, however, the :class:`dict` objects holding the instance "
"attributes are not included in the output."
msgstr ""

#: ../../src/PyMOTW/gc/index.rst:540
msgid ""
"If seeing the uncollectable objects is not enough information to "
"understand where data is being retained, you can enable "
":const:`DEBUG_SAVEALL` to cause :mod:`gc` to preserve all objects it "
"finds without any references in the :obj:`garbage` list, so you can "
"examine them.  This is helpful if, for example, you don't have access to "
"the constructor to print the object id when each object is created."
msgstr ""

#: ../../src/PyMOTW/gc/index.rst:577
msgid ""
"For simplicity, :const:`DEBUG_LEAK` is defined as a combination of all of"
" the other options."
msgstr ""

#: ../../src/PyMOTW/gc/index.rst:584
msgid ""
"Keep in mind that because :const:`DEBUG_SAVEALL` is enabled by "
":const:`DEBUG_LEAK`, even the unreferenced objects that would normally "
"have been collected and deleted are retained."
msgstr ""

#: ../../src/PyMOTW/gc/index.rst:618
msgid "`gc <http://docs.python.org/library/gc.html>`_"
msgstr ""

#: ../../src/PyMOTW/gc/index.rst:618
msgid "The standard library documentation for this module."
msgstr ""

#: ../../src/PyMOTW/gc/index.rst:623
msgid ":mod:`weakref`"
msgstr ""

#: ../../src/PyMOTW/gc/index.rst:621
msgid ""
"The :mod:`weakref` module gives you references to objects without "
"increasing their reference count, so they can still be garbage collected."
msgstr ""

#: ../../src/PyMOTW/gc/index.rst:626
msgid ""
"`Supporting Cyclic Garbage Collection "
"<http://docs.python.org/c-api/gcsupport.html>`__"
msgstr ""

#: ../../src/PyMOTW/gc/index.rst:626
msgid "Background material from Python's C API documentation."
msgstr ""

#: ../../src/PyMOTW/gc/index.rst:628
msgid ""
"`How does Python manage memory? <http://effbot.org/pyfaq/how-does-python-"
"manage-memory.htm>`__"
msgstr ""

#: ../../src/PyMOTW/gc/index.rst:629
msgid "An article on Python memory management by Fredrik Lundh."
msgstr ""

