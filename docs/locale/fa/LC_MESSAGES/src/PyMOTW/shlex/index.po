# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2016, Python-ir.org
# This file is distributed under the same license as the Python-ir package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2016.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python-ir 0.1\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2016-05-07 20:31+0430\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.3.4\n"

#: ../../src/PyMOTW/shlex/index.rst:3
msgid "shlex -- Lexical analysis of shell-style syntaxes."
msgstr ""

#: ../../src/PyMOTW/shlex/index.rst:8
msgid "Lexical analysis of shell-style syntaxes."
msgstr ""

#: ../../src/PyMOTW/shlex/index.rst:9
msgid "1.5.2, with additions in later versions"
msgstr ""

#: ../../src/PyMOTW/shlex/index.rst:11
msgid ""
"The shlex module implements a class for parsing simple shell-like "
"syntaxes. It can be used for writing your own domain specific language, "
"or for parsing quoted strings (a task that is more complex than it seems,"
" at first)."
msgstr ""

#: ../../src/PyMOTW/shlex/index.rst:16
msgid "Quoted Strings"
msgstr ""

#: ../../src/PyMOTW/shlex/index.rst:18
msgid ""
"A common problem when working with input text is to identify a sequence "
"of quoted words as a single entity. Splitting the text on quotes does not"
" always work as expected, especially if there are nested levels of "
"quotes. Take the following text:"
msgstr ""

#: ../../src/PyMOTW/shlex/index.rst:26
msgid ""
"A naive approach might attempt to construct a regular expression to find "
"the parts of the text outside the quotes to separate them from the text "
"inside the quotes, or vice versa. Such an approach would be unnecessarily"
" complex and prone to errors resulting from edge cases like apostrophes "
"or even typos. A better solution is to use a true parser, such as the one"
" provided by the :mod:`shlex` module. Here is a simple example that "
"prints the tokens identified in the input file:"
msgstr ""

#: ../../src/PyMOTW/shlex/index.rst:38
msgid ""
"When run on data with embedded quotes, the parser produces the list of "
"tokens we expect:"
msgstr ""

#: ../../src/PyMOTW/shlex/index.rst:69
msgid ""
"Isolated quotes such as apostrophes are also handled.  Given this input "
"file:"
msgstr ""

#: ../../src/PyMOTW/shlex/index.rst:75
msgid "The token with the embedded apostrophe is no problem:"
msgstr ""

#: ../../src/PyMOTW/shlex/index.rst:102
msgid "Embedded Comments"
msgstr ""

#: ../../src/PyMOTW/shlex/index.rst:104
msgid ""
"Since the parser is intended to be used with command languages, it needs "
"to handle comments. By default, any text following a # is considered part"
" of a comment, and ignored. Due to the nature of the parser, only single "
"character comment prefixes are supported. The set of comment characters "
"used can be configured through the commenters property."
msgstr ""

#: ../../src/PyMOTW/shlex/index.rst:136
msgid "Split"
msgstr ""

#: ../../src/PyMOTW/shlex/index.rst:138
msgid ""
"If you just need to split an existing string into component tokens, the "
"convenience function :func:`split()` is a simple wrapper around the "
"parser."
msgstr ""

#: ../../src/PyMOTW/shlex/index.rst:146
msgid "The result is a list:"
msgstr ""

#: ../../src/PyMOTW/shlex/index.rst:165
msgid "Including Other Sources of Tokens"
msgstr ""

#: ../../src/PyMOTW/shlex/index.rst:167
msgid ""
"The :class:`shlex` class includes several configuration properties which "
"allow us to control its behavior. The *source* property enables a feature"
" for code (or configuration) re-use by allowing one token stream to "
"include another. This is similar to the Bourne shell ``source`` operator,"
" hence the name."
msgstr ""

#: ../../src/PyMOTW/shlex/index.rst:177
msgid ""
"Notice the string ``source quotes.txt`` embedded in the original text. "
"Since the source property of the lexer is set to \"source\", when the "
"keyword is encountered the filename appearing in the next title is "
"automatically included. In order to cause the filename to appear as a "
"single token, the ``.`` character needs to be added to the list of "
"characters that are included in words (otherwise \"``quotes.txt``\" "
"becomes three tokens, \"``quotes``\", \"``.``\", \"``txt``\"). The output"
" looks like:"
msgstr ""

#: ../../src/PyMOTW/shlex/index.rst:220
msgid ""
"The \"source\" feature uses a method called :func:`sourcehook()` to load "
"the additional input source, so you can subclass :class:`shlex` to "
"provide your own implementation to load data from anywhere."
msgstr ""

#: ../../src/PyMOTW/shlex/index.rst:225
msgid "Controlling the Parser"
msgstr ""

#: ../../src/PyMOTW/shlex/index.rst:227
msgid ""
"I have already given an example changing the *wordchars* value to control"
" which characters are included in words. It is also possible to set the "
"*quotes* character to use additional or alternative quotes. Each quote "
"must be a single character, so it is not possible to have different open "
"and close quotes (no parsing on parentheses, for example)."
msgstr ""

#: ../../src/PyMOTW/shlex/index.rst:238
msgid "In this example, each table cell is wrapped in vertical bars:"
msgstr ""

#: ../../src/PyMOTW/shlex/index.rst:257
msgid ""
"It is also possible to control the whitespace characters used to split "
"words. If we modify the example in shlex_example.py to include period and"
" comma, as follows:"
msgstr ""

#: ../../src/PyMOTW/shlex/index.rst:265
msgid "The results change to:"
msgstr ""

#: ../../src/PyMOTW/shlex/index.rst:295
msgid "Error Handling"
msgstr ""

#: ../../src/PyMOTW/shlex/index.rst:297
msgid ""
"When the parser encounters the end of its input before all quoted strings"
" are closed, it raises :ref:`ValueError <exceptions-ValueError>`. When "
"that happens, it is useful to examine some of the properties of the "
"parser maintained as it processes the input. For example, *infile* refers"
" to the name of the file being processed (which might be different from "
"the original file, if one file sources another). The *lineno* reports the"
" line when the error is discovered. The *lineno* is typically the end of "
"the file, which may be far away from the first quote. The *token* "
"attribute contains the buffer of text not already included in a valid "
"token. The :func:`error_leader()` method produces a message prefix in a "
"style similar to Unix compilers, which enables editors such as emacs to "
"parse the error and take the user directly to the invalid line."
msgstr ""

#: ../../src/PyMOTW/shlex/index.rst:315
msgid "The example above produces this output:"
msgstr ""

#: ../../src/PyMOTW/shlex/index.rst:343
msgid "POSIX vs. Non-POSIX Parsing"
msgstr ""

#: ../../src/PyMOTW/shlex/index.rst:345
msgid ""
"The default behavior for the parser is to use a backwards-compatible "
"style which is not POSIX-compliant. For POSIX behavior, set the posix "
"argument when constructing the parser."
msgstr ""

#: ../../src/PyMOTW/shlex/index.rst:353
msgid "Here are a few examples of the differences in parsing behavior:"
msgstr ""

#: ../../src/PyMOTW/shlex/index.rst:402
msgid "`shlex <http://docs.python.org/lib/module-shlex.html>`_"
msgstr ""

#: ../../src/PyMOTW/shlex/index.rst:402
msgid "Standard library documentation for this module."
msgstr ""

#: ../../src/PyMOTW/shlex/index.rst:405
msgid ":mod:`cmd`"
msgstr ""

#: ../../src/PyMOTW/shlex/index.rst:405
msgid "Tools for building interactive command interpreters."
msgstr ""

#: ../../src/PyMOTW/shlex/index.rst:408
msgid ":mod:`optparse`"
msgstr ""

#: ../../src/PyMOTW/shlex/index.rst:408 ../../src/PyMOTW/shlex/index.rst:411
msgid "Command line option parsing."
msgstr ""

#: ../../src/PyMOTW/shlex/index.rst:410
msgid ":mod:`getopt`"
msgstr ""

