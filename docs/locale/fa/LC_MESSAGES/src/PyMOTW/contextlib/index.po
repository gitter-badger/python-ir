# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2016, Python-ir.org
# This file is distributed under the same license as the Python-ir package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2016.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python-ir 0.1\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2016-05-07 20:31+0430\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.3.4\n"

#: ../../src/PyMOTW/contextlib/index.rst:3
msgid "contextlib -- Context manager utilities"
msgstr ""

#: ../../src/PyMOTW/contextlib/index.rst:8
msgid "Utilities for creating and working with context managers."
msgstr ""

#: ../../src/PyMOTW/contextlib/index.rst:9
msgid "2.5 and later"
msgstr ""

#: ../../src/PyMOTW/contextlib/index.rst:11
msgid ""
"The :mod:`contextlib` module contains utilities for working with context "
"managers and the :command:`with` statement."
msgstr ""

#: ../../src/PyMOTW/contextlib/index.rst:15
msgid ""
"Context managers are tied to the :command:`with` statement. Since "
":command:`with` is officially part of Python 2.6, you have to import it "
"from :mod:`__future__` before using contextlib in Python 2.5."
msgstr ""

#: ../../src/PyMOTW/contextlib/index.rst:20
msgid "Context Manager API"
msgstr ""

#: ../../src/PyMOTW/contextlib/index.rst:22
msgid ""
"A *context manager* is responsible for a resource within a code block, "
"possibly creating it when the block is entered and then cleaning it up "
"after the block is exited.  For example, files support the context "
"manager API to make it easy to ensure they are closed after all reading "
"or writing is done."
msgstr ""

#: ../../src/PyMOTW/contextlib/index.rst:32
msgid ""
"A context manager is enabled by the :command:`with` statement, and the "
"API involves two methods.  The :func:`__enter__` method is run when "
"execution flow enters the code block inside the :command:`with`.  It "
"returns an object to be used within the context.  When execution flow "
"leaves the :command:`with` block, the :func:`__exit__` method of the "
"context manager is called to clean up any resources being used."
msgstr ""

#: ../../src/PyMOTW/contextlib/index.rst:43
msgid ""
"Combining a context manager and the :command:`with` statement is a more "
"compact way of writing a ``try:finally`` block, since the context "
"manager's :func:`__exit__` method is always called, even if an exception "
"is raised."
msgstr ""

#: ../../src/PyMOTW/contextlib/index.rst:63
msgid ""
":func:`__enter__` can return any object to be associated with a name "
"specified in the :command:`as` clause of the :command:`with` statement.  "
"In this example, the :class:`Context` returns an object that uses the "
"open context."
msgstr ""

#: ../../src/PyMOTW/contextlib/index.rst:72
msgid ""
"It can be a little confusing, but the value associated with the variable "
":data:`c` is the object returned by :func:`__enter__` and *not* the "
":class:`Context` instance created in the :command:`with` statement."
msgstr ""

#: ../../src/PyMOTW/contextlib/index.rst:94
msgid ""
"The :func:`__exit__` method receives arguments containing details of any "
"exception raised in the :command:`with` block."
msgstr ""

#: ../../src/PyMOTW/contextlib/index.rst:101
msgid ""
"If the context manager can handle the exception, :func:`__exit__` should "
"return a true value to indicate that the exception does not need to be "
"propagated.  Returning false causes the exception to be re-raised after "
":func:`__exit__` returns."
msgstr ""

#: ../../src/PyMOTW/contextlib/index.rst:130
msgid "From Generator to Context Manager"
msgstr ""

#: ../../src/PyMOTW/contextlib/index.rst:132
msgid ""
"Creating context managers the traditional way, by writing a class with "
":func:`__enter__()` and :func:`__exit__()` methods, is not difficult. But"
" sometimes it is more overhead than you need just to manage a trivial bit"
" of context. In those sorts of situations, you can use the "
":func:`contextmanager()` decorator to convert a generator function into a"
" context manager."
msgstr ""

#: ../../src/PyMOTW/contextlib/index.rst:143
msgid ""
"The generator should initialize the context, yield exactly one time, then"
" clean up the context. The value yielded, if any, is bound to the "
"variable in the :command:`as` clause of the :command:`with` statement. "
"Exceptions from within the :command:`with` block are re-raised inside the"
" generator, so they can be handled there."
msgstr ""

#: ../../src/PyMOTW/contextlib/index.rst:179
msgid "Nesting Contexts"
msgstr ""

#: ../../src/PyMOTW/contextlib/index.rst:181
msgid ""
"At times it is necessary to manage multiple contexts simultaneously (such"
" as when copying data between input and output file handles, for "
"example). It is possible to nest :command:`with` statements one inside "
"another. If the outer contexts do not need their own separate block, "
"though, this adds to the indention level without giving any real benefit."
" Using :func:`nested()` nests the contexts using a single :command:`with`"
" statement."
msgstr ""

#: ../../src/PyMOTW/contextlib/index.rst:193
msgid ""
"Notice that the contexts are exited in the reverse order in which they "
"are entered."
msgstr ""

#: ../../src/PyMOTW/contextlib/index.rst:214
msgid ""
"In Python 2.7 and later, :func:`nested` is deprecated because the "
":command:`with` statement supports nesting directly."
msgstr ""

#: ../../src/PyMOTW/contextlib/index.rst:221
msgid ""
"Each context manager and optional :command:`as` clause are separated by a"
" comma (``,``).  The effect is similar to using :func:`nested`, but "
"avoids some of the edge-cases around error handling that :func:`nested` "
"could not implement correctly."
msgstr ""

#: ../../src/PyMOTW/contextlib/index.rst:246
msgid "Closing Open Handles"
msgstr ""

#: ../../src/PyMOTW/contextlib/index.rst:248
msgid ""
"The :class:`file` class supports the context manager API directly, but "
"some other objects that represent open handles do not. The example given "
"in the standard library documentation for :mod:`contextlib` is the object"
" returned from :func:`urllib.urlopen`.  There are other legacy classes "
"that use a :func:`close` method but do not support the context manager "
"API. To ensure that a handle is closed, use :func:`closing()` to create a"
" context manager for it."
msgstr ""

#: ../../src/PyMOTW/contextlib/index.rst:260
msgid ""
"The handle is closed whether there is an error in the :command:`with` "
"block or not."
msgstr ""

#: ../../src/PyMOTW/contextlib/index.rst:287
msgid "`contextlib <http://docs.python.org/library/contextlib.html>`_"
msgstr ""

#: ../../src/PyMOTW/contextlib/index.rst:287
msgid "The standard library documentation for this module."
msgstr ""

#: ../../src/PyMOTW/contextlib/index.rst:290
msgid ":pep:`343`"
msgstr ""

#: ../../src/PyMOTW/contextlib/index.rst:290
msgid "The :command:`with` statement."
msgstr ""

#: ../../src/PyMOTW/contextlib/index.rst:293
msgid ""
"`Context Manager Types "
"<http://docs.python.org/library/stdtypes.html#typecontextmanager>`__"
msgstr ""

#: ../../src/PyMOTW/contextlib/index.rst:293
msgid ""
"Description of the context manager API from the standard library "
"documentation."
msgstr ""

#: ../../src/PyMOTW/contextlib/index.rst:295
msgid ""
"`With Statement Context Managers "
"<http://docs.python.org/reference/datamodel.html#context-managers>`__"
msgstr ""

#: ../../src/PyMOTW/contextlib/index.rst:296
msgid "Description of the context manager API from the Python Reference Guide."
msgstr ""

