# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2016, Python-ir.org
# This file is distributed under the same license as the Python-ir package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2016.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python-ir 0.1\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2016-05-07 20:31+0430\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.3.4\n"

#: ../../src/PyMOTW/inspect/index.rst:3
msgid "inspect -- Inspect live objects"
msgstr ""

#: ../../src/PyMOTW/inspect/index.rst:9
msgid ""
"The inspect module provides functions for introspecting on live objects "
"and their source code."
msgstr ""

#: ../../src/PyMOTW/inspect/index.rst:11
msgid "added in 2.1, with updates in 2.3 and 2.5"
msgstr ""

#: ../../src/PyMOTW/inspect/index.rst:13
msgid ""
"The :mod:`inspect` module provides functions for learning about live "
"objects, including modules, classes, instances, functions, and methods. "
"You can use functions in this module to retrieve the original source code"
" for a function, look at the arguments to a method on the stack, and "
"extract the sort of information useful for producing library "
"documentation for your source code.  My own `CommandLineApp`_ module uses"
" inspect to determine the valid options to a command line program, as "
"well as any arguments and their names so command line programs are self-"
"documenting and the help text is generated automatically."
msgstr ""

#: ../../src/PyMOTW/inspect/index.rst:25
msgid "Module Information"
msgstr ""

#: ../../src/PyMOTW/inspect/index.rst:27
msgid ""
"The first kind of introspection supported lets you probe live objects to "
"learn about them. For example, it is possible to discover the classes and"
" functions in a module, the methods of a class, etc. Let's start with the"
" module-level details and work our way down to the function level."
msgstr ""

#: ../../src/PyMOTW/inspect/index.rst:33
msgid ""
"To determine how the interpreter will treat and load a file as a module, "
"use :func:`getmoduleinfo()`. Pass a filename as the only argument, and "
"the return value is a tuple including the module base name, the suffix of"
" the file, the mode that will be used for reading the file, and the "
"module type as defined in the :mod:`imp` module. It is important to note "
"that the function looks only at the file's name, and does not actually "
"check if the file exists or try to read the file."
msgstr ""

#: ../../src/PyMOTW/inspect/index.rst:46
msgid "Here are a few sample runs:"
msgstr ""

#: ../../src/PyMOTW/inspect/index.rst:78
msgid "Example Module"
msgstr ""

#: ../../src/PyMOTW/inspect/index.rst:80
msgid ""
"The rest of the examples for this tutorial use a single example file "
"source file, found in ``PyMOTW/inspect/example.py`` and which is included"
" below.  The file is also available as part of the source distribution "
"associated with this series of articles."
msgstr ""

#: ../../src/PyMOTW/inspect/index.rst:90
msgid "Modules"
msgstr ""

#: ../../src/PyMOTW/inspect/index.rst:92
msgid ""
"It is possible to probe live objects to determine their components using "
":func:`getmembers()`. The arguments to :func:`getmembers()` are an object"
" to scan (a module, class, or instance) and an optional predicate "
"function that is used to filter the objects returned. The return value is"
" a list of tuples with 2 values: the name of the member, and the type of "
"the member. The inspect module includes several such predicate functions "
"with names like :func:`ismodule()`, :func:`isclass()`, etc.  You can "
"provide your own predicate function as well."
msgstr ""

#: ../../src/PyMOTW/inspect/index.rst:102
msgid ""
"The types of members that might be returned depend on the type of object "
"scanned. Modules can contain classes and functions; classes can contain "
"methods and attributes; and so on."
msgstr ""

#: ../../src/PyMOTW/inspect/index.rst:110
msgid ""
"This sample prints the members of the example module. Modules have a set "
"of ``__builtins__``, which are ignored in the output for this example "
"because they are not actually part of the module and the list is long."
msgstr ""

#: ../../src/PyMOTW/inspect/index.rst:129
msgid ""
"The predicate argument can be used to filter the types of objects "
"returned."
msgstr ""

#: ../../src/PyMOTW/inspect/index.rst:135
msgid "Notice that only classes are included in the output, now:"
msgstr ""

#: ../../src/PyMOTW/inspect/index.rst:152
msgid "Classes"
msgstr ""

#: ../../src/PyMOTW/inspect/index.rst:154
msgid ""
"Classes are scanned using :func:`getmembers()` in the same way as "
"modules, though the types of members are different."
msgstr ""

#: ../../src/PyMOTW/inspect/index.rst:161
msgid ""
"Since no filtering is applied, the output shows the attributes, methods, "
"slots, and other members of the class:"
msgstr ""

#: ../../src/PyMOTW/inspect/index.rst:186
msgid "To find the methods of a class, use the :func:`ismethod()` predicate:"
msgstr ""

#: ../../src/PyMOTW/inspect/index.rst:206
msgid ""
"If we look at class B, we see the over-ride for :func:`get_name()` as "
"well as the new method, and the inherited :func:`__init__()` method "
"implented in A."
msgstr ""

#: ../../src/PyMOTW/inspect/index.rst:214
msgid ""
"Notice that even though :func:`__init__()` is inherited from :class:`A`, "
"it is identified as a method of :class:`B`."
msgstr ""

#: ../../src/PyMOTW/inspect/index.rst:233
msgid "Documentation Strings"
msgstr ""

#: ../../src/PyMOTW/inspect/index.rst:235
msgid ""
"The docstring for an object can be retrieved with :func:`getdoc()`. The "
"return value is the ``__doc__`` attribute with tabs expanded to spaces "
"and with indentation made uniform."
msgstr ""

#: ../../src/PyMOTW/inspect/index.rst:243
msgid "Notice the difference in indentation on the second line of the doctring:"
msgstr ""

#: ../../src/PyMOTW/inspect/index.rst:265
msgid ""
"In addition to the actual docstring, it is possible to retrieve the "
"comments from the source file where an object is implemented, if the "
"source is available. The :func:`getcomments()` function looks at the "
"source of the object and finds comments on lines preceding the "
"implementation."
msgstr ""

#: ../../src/PyMOTW/inspect/index.rst:275
msgid ""
"The lines returned include the comment prefix, but any whitespace prefix "
"is stripped off."
msgstr ""

#: ../../src/PyMOTW/inspect/index.rst:291
msgid ""
"When a module is passed to :func:`getcomments()`, the return value is "
"always the first comment in the module."
msgstr ""

#: ../../src/PyMOTW/inspect/index.rst:298
msgid ""
"Notice that contiguous lines from the example file are included as a "
"single comment, but as soon as a blank line appears the comment is "
"stopped."
msgstr ""

#: ../../src/PyMOTW/inspect/index.rst:316
msgid "Retrieving Source"
msgstr ""

#: ../../src/PyMOTW/inspect/index.rst:318
msgid ""
"If the ``.py`` file is available for a module, the original source code "
"for the class or method can be retrieved using :func:`getsource()` and "
":func:`getsourcelines()`."
msgstr ""

#: ../../src/PyMOTW/inspect/index.rst:326
msgid "The original indent level is retained in this case."
msgstr ""

#: ../../src/PyMOTW/inspect/index.rst:343
msgid ""
"When a class is passed in, all of the methods for the class are included "
"in the output."
msgstr ""

#: ../../src/PyMOTW/inspect/index.rst:370
msgid ""
"If you need the lines of source split up, it can be easier to use "
":func:`getsourcelines()` instead of :func:`getsource()`. The return value"
" from :func:`getsourcelines()` is a tuple containing a list of strings "
"(the lines from the source file), and a starting line number in the file "
"where the source appears."
msgstr ""

#: ../../src/PyMOTW/inspect/index.rst:395
msgid ""
"If the source file is not available, :func:`getsource()` and "
":func:`getsourcelines()` raise an :ref:`IOError <exceptions-IOError>`."
msgstr ""

#: ../../src/PyMOTW/inspect/index.rst:399
msgid "Method and Function Arguments"
msgstr ""

#: ../../src/PyMOTW/inspect/index.rst:401
msgid ""
"In addition to the documentation for a function or method, it is possible"
" to ask for a complete specification of the arguments the callable takes,"
" including default values. The :func:`getargspec()` function returns a "
"tuple containing the list of positional argument names, the name of any "
"variable positional arguments (e.g., ``*args``), the names of any "
"variable named arguments (e.g., ``**kwds``), and default values for the "
"arguments. If there are default values, they match up with the end of the"
" positional argument list."
msgstr ""

#: ../../src/PyMOTW/inspect/index.rst:415
msgid ""
"Note that the first argument, *arg1*, does not have a default value. The "
"single default therefore is matched up with *arg2*."
msgstr ""

#: ../../src/PyMOTW/inspect/index.rst:436
msgid "Class Hierarchies"
msgstr ""

#: ../../src/PyMOTW/inspect/index.rst:438
msgid ""
":mod:`inspect` includes two methods for working directly with class "
"hierarchies. The first, :func:`getclasstree()`, creates a tree-like data "
"structure using nested lists and tuples based on the classes it is given "
"and their base classes. Each element in the list returned is either a "
"tuple with a class and its base classes, or another list containing "
"tuples for subclasses."
msgstr ""

#: ../../src/PyMOTW/inspect/index.rst:457
msgid ""
"The output from this example is the \"tree\" of inheritance for the A, B,"
" C, and D classes. Note that D appears twice, since it inherits from both"
" C and A."
msgstr ""

#: ../../src/PyMOTW/inspect/index.rst:478
msgid ""
"If we call :func:`getclasstree()` with ``unique=True``, the output is "
"different."
msgstr ""

#: ../../src/PyMOTW/inspect/index.rst:485
msgid "This time, D only appears in the output once:"
msgstr ""

#: ../../src/PyMOTW/inspect/index.rst:505
msgid "Method Resolution Order"
msgstr ""

#: ../../src/PyMOTW/inspect/index.rst:507
msgid ""
"The other function for working with class hierarchies is "
":func:`getmro()`, which returns a tuple of classes in the order they "
"should be scanned when resolving an attribute that might be inherited "
"from a base class. Each class in the sequence appears only once."
msgstr ""

#: ../../src/PyMOTW/inspect/index.rst:516
msgid ""
"This output demonstrates the \"depth-first\" nature of the MRO_ search. "
"For B_First, A also comes before C in the search order, because B is "
"derived from A."
msgstr ""

#: ../../src/PyMOTW/inspect/index.rst:546
msgid "The Stack and Frames"
msgstr ""

#: ../../src/PyMOTW/inspect/index.rst:548
msgid ""
"In addition to introspection of code objects, :mod:`inspect` includes "
"functions for inspecting the runtime environment while a program is "
"running. Most of these functions work with the call stack, and operate on"
" \"call frames\". Each frame record in the stack is a 6 element tuple "
"containing the frame object, the filename where the code exists, the line"
" number in that file for the current line being run, the function name "
"being called, a list of lines of context from the source file, and the "
"index into that list of the current line. Typically such information is "
"used to build tracebacks when exceptions are raised. It can also be "
"useful when debugging programs, since the stack frames can be "
"interrogated to discover the argument values passed into the functions."
msgstr ""

#: ../../src/PyMOTW/inspect/index.rst:561
msgid ""
":func:`currentframe()` returns the frame at the top of the stack (for the"
" current function). :func:`getargvalues()` returns a tuple with argument "
"names, the names of the variable arguments, and a dictionary with local "
"values from the frame. By combining them, we can see the arguments to "
"functions and local variables at different points in the call stack."
msgstr ""

#: ../../src/PyMOTW/inspect/index.rst:572
msgid ""
"The value for ``local_variable`` is included in the frame's local "
"variables even though it is not an argument to the function."
msgstr ""

#: ../../src/PyMOTW/inspect/index.rst:591
msgid ""
"Using :func:`stack()`, it is also possible to access all of the stack "
"frames from the current frame to the first caller. This example is "
"similar to the one above, except it waits until reaching the end of the "
"recursion to print the stack information."
msgstr ""

#: ../../src/PyMOTW/inspect/index.rst:600
msgid ""
"The last part of the output represents the main program, outside of the "
"recurse function."
msgstr ""

#: ../../src/PyMOTW/inspect/index.rst:634
msgid ""
"There are other functions for building lists of frames in different "
"contexts, such as when an exception is being processed. See the "
"documentation for :func:`trace()`, :func:`getouterframes()`, and "
":func:`getinnerframes()` for more details."
msgstr ""

#: ../../src/PyMOTW/inspect/index.rst:643
msgid "`inspect <http://docs.python.org/library/inspect.html>`_"
msgstr ""

#: ../../src/PyMOTW/inspect/index.rst:643
msgid "The standard library documentation for this module."
msgstr ""

#: ../../src/PyMOTW/inspect/index.rst:648
msgid "`CommandLineApp`_"
msgstr ""

#: ../../src/PyMOTW/inspect/index.rst:646
msgid "Base class for object-oriented command line applications"
msgstr ""

#: ../../src/PyMOTW/inspect/index.rst:651
msgid ""
"`Python 2.3 Method Resolution Order "
"<http://www.python.org/download/releases/2.3/mro/>`__"
msgstr ""

#: ../../src/PyMOTW/inspect/index.rst:651
msgid ""
"Documentation for the C3 Method Resolution order used by Python 2.3 and "
"later."
msgstr ""

