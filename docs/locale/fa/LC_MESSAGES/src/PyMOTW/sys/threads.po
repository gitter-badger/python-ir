# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2016, Python-ir.org
# This file is distributed under the same license as the Python-ir package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2016.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python-ir 0.1\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2016-05-07 20:31+0430\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.3.4\n"

#: ../../src/PyMOTW/sys/threads.rst:5
msgid "Low-level Thread Support"
msgstr ""

#: ../../src/PyMOTW/sys/threads.rst:7
msgid ""
":mod:`sys` includes low-level functions for controlling and debugging "
"thread behavior."
msgstr ""

#: ../../src/PyMOTW/sys/threads.rst:11
msgid "Check Interval"
msgstr ""

#: ../../src/PyMOTW/sys/threads.rst:13
msgid ""
"Python 2 uses a form of cooperative multitasking in its thread "
"implementation.  At a fixed interval, bytecode execution is paused and "
"the interpreter checks if any signal handlers need to be executed. During"
" the same interval check, the global interpreter lock is also released by"
" the current thread and then reacquired, giving other threads an "
"opportunity to take over execution by grabbing the lock first."
msgstr ""

#: ../../src/PyMOTW/sys/threads.rst:21
msgid ""
"The default check interval is 100 bytecodes and the current value can "
"always be retrieved with :func:`sys.getcheckinterval`.  Changing the "
"interval with :func:`sys.setcheckinterval` may have an impact on the "
"performance of an application, depending on the nature of the operations "
"being performed."
msgstr ""

#: ../../src/PyMOTW/sys/threads.rst:31
msgid ""
"When the check interval is smaller than the number of bytecodes in a "
"thread, the interpreter may give another thread control so that it runs "
"for a while.  This is illustrated in the first set of output where the "
"check interval is set to 100 (the default) and 1000 extra loop iterations"
" are performed for each step through the ``i`` loop."
msgstr ""

#: ../../src/PyMOTW/sys/threads.rst:37
msgid ""
"On the other hand, when the check interval is *greater* than the number "
"of bytecodes being executed by a thread that doesn't release control for "
"another reason, the thread will finish its work before the interval comes"
" up.  This is illustrated by the order of the name values in the queue in"
" the second example."
msgstr ""

#: ../../src/PyMOTW/sys/threads.rst:83
msgid ""
"Modifying the check interval is not as clearly useful as it might seem.  "
"Many other factors may control the context switching behavior of Python's"
" threads.  For example, if a thread performs I/O, it releases the GIL and"
" may therefore allow another thread to take over execution."
msgstr ""

#: ../../src/PyMOTW/sys/threads.rst:93
msgid ""
"This example is modified from the first so that the thread prints "
"directly to :const:`sys.stdout` instead of appending to a queue.  The "
"output is much less predictable."
msgstr ""

#: ../../src/PyMOTW/sys/threads.rst:140
msgid ":mod:`dis`"
msgstr ""

#: ../../src/PyMOTW/sys/threads.rst:140
msgid ""
"Disassembling your Python code with the dis module is one way to count "
"bytecodes."
msgstr ""

#: ../../src/PyMOTW/sys/threads.rst:145
msgid "Debugging"
msgstr ""

#: ../../src/PyMOTW/sys/threads.rst:147
msgid ""
"Identifying deadlocks can be on of the most difficult aspects of working "
"with threads.  :func:`sys._current_frames` can help by showing exactly "
"where a thread is stopped."
msgstr ""

#: ../../src/PyMOTW/sys/threads.rst:154
msgid ""
"The dictionary returned by :func:`sys._current_frames` is keyed on the "
"thread identifier, rather than its name.  A little work is needed to map "
"those identifiers back to the thread object."
msgstr ""

#: ../../src/PyMOTW/sys/threads.rst:158
msgid ""
"Since **Thread-1** does not sleep, it finishes before its status is "
"checked.  Since it is no longer active, it does not appear in the output."
"  **Thread-2** acquires the lock *blocker*, then sleeps for a short "
"period.  Meanwhile **Thread-3** tries to acquire *blocker* but cannot "
"because **Thread-2** already has it."
msgstr ""

#: ../../src/PyMOTW/sys/threads.rst:185
msgid ":mod:`threading`"
msgstr ""

#: ../../src/PyMOTW/sys/threads.rst:185
msgid "The threading module includes classes for creating Python threads."
msgstr ""

#: ../../src/PyMOTW/sys/threads.rst:188
msgid ":mod:`Queue`"
msgstr ""

#: ../../src/PyMOTW/sys/threads.rst:188
msgid ""
"The Queue module provides a thread-safe implementation of a FIFO data "
"structure."
msgstr ""

#: ../../src/PyMOTW/sys/threads.rst:191
msgid ""
"`Python Threads and the Global Interpreter Lock "
"<http://jessenoller.com/2009/02/01/python-threads-and-the-global-"
"interpreter-lock/>`_"
msgstr ""

#: ../../src/PyMOTW/sys/threads.rst:191
msgid "Jesse Noller's article from the December 2007 issue of Python Magazine."
msgstr ""

#: ../../src/PyMOTW/sys/threads.rst:193
msgid "`Inside the Python GIL <http://www.dabeaz.com/python/GIL.pdf>`_"
msgstr ""

#: ../../src/PyMOTW/sys/threads.rst:194
msgid ""
"Presentation by David Beazley describing thread implementation and "
"performance issues, including how the check interval and GIL are related."
msgstr ""

